"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyDecs2301;
var _checkInRHS = require("checkInRHS");
var _setFunctionName = require("setFunctionName");
var _toPropertyKey = require("toPropertyKey");
function applyDecs2301Factory() {
  function createAddInitializerMethod(initializers, decoratorFinishedRef) {
    return function addInitializer(initializer) {
      assertNotFinished(decoratorFinishedRef, "addInitializer");
      assertCallable(initializer, "An initializer");
      initializers.push(initializer);
    };
  }
  function assertInstanceIfPrivate(has, target) {
    if (!has(target)) {
      throw new TypeError("Attempted to access private element on non-instance");
    }
  }
  function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, value, hasPrivateBrand) {
    var kindStr;
    switch (kind) {
      case 1:
        kindStr = "accessor";
        break;
      case 2:
        kindStr = "method";
        break;
      case 3:
        kindStr = "getter";
        break;
      case 4:
        kindStr = "setter";
        break;
      default:
        kindStr = "field";
    }
    var ctx = {
      kind: kindStr,
      name: isPrivate ? "#" + name : _toPropertyKey(name),
      static: isStatic,
      private: isPrivate
    };
    var decoratorFinishedRef = {
      v: false
    };
    if (kind !== 0) {
      ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
    }
    var get, set;
    if (!isPrivate && (kind === 0 || kind === 2)) {
      get = function (target) {
        return target[name];
      };
      if (kind === 0) {
        set = function (target, v) {
          target[name] = v;
        };
      }
    } else if (kind === 2) {
      get = function (target) {
        assertInstanceIfPrivate(hasPrivateBrand, target);
        return desc.value;
      };
    } else {
      var t = kind === 0 || kind === 1;
      if (t || kind === 3) {
        if (isPrivate) {
          get = function (target) {
            assertInstanceIfPrivate(hasPrivateBrand, target);
            return desc.get.call(target);
          };
        } else {
          get = function (target) {
            return desc.get.call(target);
          };
        }
      }
      if (t || kind === 4) {
        if (isPrivate) {
          set = function (target, value) {
            assertInstanceIfPrivate(hasPrivateBrand, target);
            desc.set.call(target, value);
          };
        } else {
          set = function (target, value) {
            desc.set.call(target, value);
          };
        }
      }
    }
    var has = isPrivate ? hasPrivateBrand.bind() : function (target) {
      return name in target;
    };
    ctx.access = get && set ? {
      get: get,
      set: set,
      has: has
    } : get ? {
      get: get,
      has: has
    } : {
      set: set,
      has: has
    };
    try {
      return dec(value, ctx);
    } finally {
      decoratorFinishedRef.v = true;
    }
  }
  function assertNotFinished(decoratorFinishedRef, fnName) {
    if (decoratorFinishedRef.v) {
      throw new Error("attempted to call " + fnName + " after decoration was finished");
    }
  }
  function assertCallable(fn, hint) {
    if (typeof fn !== "function") {
      throw new TypeError(hint + " must be a function");
    }
  }
  function assertValidReturnValue(kind, value) {
    var type = typeof value;
    if (kind === 1) {
      if (type !== "object" || value === null) {
        throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
      }
      if (value.get !== undefined) {
        assertCallable(value.get, "accessor.get");
      }
      if (value.set !== undefined) {
        assertCallable(value.set, "accessor.set");
      }
      if (value.init !== undefined) {
        assertCallable(value.init, "accessor.init");
      }
    } else if (type !== "function") {
      var hint;
      if (kind === 0) {
        hint = "field";
      } else if (kind === 10) {
        hint = "class";
      } else {
        hint = "method";
      }
      throw new TypeError(hint + " decorators must return a function or void 0");
    }
  }
  function curryThis1(fn) {
    return function () {
      return fn(this);
    };
  }
  function curryThis2(fn) {
    return function (value) {
      fn(this, value);
    };
  }
  function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, hasPrivateBrand) {
    var decs = decInfo[0];
    var desc, init, prefix, value;
    if (isPrivate) {
      if (kind === 0 || kind === 1) {
        desc = {
          get: curryThis1(decInfo[3]),
          set: curryThis2(decInfo[4])
        };
        prefix = "get";
      } else {
        if (kind === 3) {
          desc = {
            get: decInfo[3]
          };
          prefix = "get";
        } else if (kind === 4) {
          desc = {
            set: decInfo[3]
          };
          prefix = "set";
        } else {
          desc = {
            value: decInfo[3]
          };
        }
      }
      if (kind !== 0) {
        if (kind === 1) {
          _setFunctionName(desc.set, "#" + name, "set");
        }
        _setFunctionName(desc[prefix || "value"], "#" + name, prefix);
      }
    } else if (kind !== 0) {
      desc = Object.getOwnPropertyDescriptor(base, name);
    }
    if (kind === 1) {
      value = {
        get: desc.get,
        set: desc.set
      };
    } else if (kind === 2) {
      value = desc.value;
    } else if (kind === 3) {
      value = desc.get;
    } else if (kind === 4) {
      value = 